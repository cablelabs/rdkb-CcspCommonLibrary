
/**********************************************************************

    module: ansc_memory.c

        For Advanced Networking Service Container (ANSC),
        BroadWay Service Delivery System

    ---------------------------------------------------------------

    copyright:

        Ashley Laurent, Inc., 1997 ~ 2001
        All Rights Reserved.

    ---------------------------------------------------------------

    description:

        This module implements the some platform-dependent and
        general utility functions related to memory management.

        *   AnscAllocateMemory2
        *   AnscReAllocateMemory2
        *   AnscFreeMemory2
        *   AnscGetMemorySize2
        *   AnscResizeMemory2
        *   AnscAllocateMemory3
        *   AnscReAllocateMemory3
        *   AnscFreeMemory3
        *   AnscGetMemorySize3
        *   AnscResizeMemory3
        *   AnscAllocateMemory4
        *   AnscReAllocateMemory4
        *   AnscFreeMemory4
        *   AnscGetMemorySize4
        *   AnscResizeMemory4
        *   AnscAllocateMemory5
        *   AnscReAllocateMemory5
        *   AnscFreeMemory5
        *   AnscGetMemorySize5
        *   AnscResizeMemory5
        *   AnscAllocateMemory6
        *   AnscReAllocateMemory6
        *   AnscFreeMemory6
        *   AnscGetMemorySize6
        *   AnscResizeMemory6
        *   AnscTraceMemoryUsage
        *   AnscTraceMemoryUsage2
        *   AnscInitializeMemoryAllocTable
        *   AnscAddMemoryAllocItem
        *   AnscGetMemoryAllocItem
        *   AnscDelMemoryAllocItem
        *   AnscTraceMemoryTable
        *   AnscTraceMemoryTable2
        *   AnscExpand2
        *   AnscMemorySetTimeMarker
        *   AnscInitializeMemoryPoolTable
        *   AnscGetMemoryPool
        *   AnscAddMemoryPool
        *   AnscDelMemoryPool
        *   AnscClrMemoryPool1
        *   AnscClrMemoryPool2
        *   AnscDelAllMemoryPools

    ---------------------------------------------------------------

    environment:

        platform independent

    ---------------------------------------------------------------

    author:

        Xuechen Yang

    ---------------------------------------------------------------

    revision:

        12/01/01    initial revision.

**********************************************************************/


#include "ansc_global.h"

/**********************************************************************
                    CONSTANT DEFINITIONS
**********************************************************************/

#define  ANSC_MEMORY_ALLOC_HEAD_SIZE                8
#define  ANSC_MEMORY_ALLOC_TAIL_SIZE                32

/**********************************************************************
                PROTOTYPES OF INTERNAL FUNCTIONS
**********************************************************************/

ANSC_HANDLE
AnscGetPrevMemoryAllocItem
    (
        void*                       pointer
    );

/**********************************************************************
                    GLOBAL VARIABLES
**********************************************************************/
static  ANSC_SPINLOCK   g_tMumSpinLock;
static  BOOL            g_bMumInitialized     = FALSE;
static  ULONG           g_ulAllocatedSizeCurr = 0;
static  ULONG           g_ulAllocatedSizePeak = 0;
static  ULONG           g_ulAllocatedItemCurr = 0;
static  ULONG           g_ulAllocatedItemPeak = 0;
static  ULONG           g_ulAllocIdentifier   = 0;
static  ULONG           g_ulTimeMarker        = 0;

static  SLIST_HEADER    g_tAllocTable[ANSC_MEMORY_ALLOC_TABLE_SIZE];
static  ANSC_SPINLOCK   g_tAllocTableSpinLock;

static  ANSC_SPINLOCK   g_tMpmSpinLock;
static  BOOL            g_bMpmInitialized     = FALSE;
static  QUEUE_HEADER    g_tMemPoolTable[ANSC_MEMORY_POOL_TABLE_SIZE];
static  ANSC_SPINLOCK   g_tMemPoolTableSpinLock;


void*
AnscAllocateMemory2
    (
        ULONG                       ulMemorySize
    )
{
    ANSC_STATUS                     returnStatus   = ANSC_STATUS_SUCCESS;
    void*                           pMemoryPointer = NULL;
    ULONG                           ulCurAllocId   = 0;

    if ( !g_bMumInitialized )
    {
        AnscInitializeSpinLock(&g_tMumSpinLock);
        AnscInitializeMemoryAllocTable();

        AnscAcquireSpinLock(&g_tMumSpinLock);
        g_bMumInitialized     = TRUE;
        g_ulAllocatedSizeCurr = 0;
        g_ulAllocatedItemCurr = 0;
        AnscReleaseSpinLock(&g_tMumSpinLock);
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr += ulMemorySize;
    g_ulAllocatedItemCurr += 1;
    ulCurAllocId           = ++g_ulAllocIdentifier;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    pMemoryPointer = AnscAllocMemory(ulMemorySize);

    AnscAddMemoryAllocItem
        (
            pMemoryPointer,
            ulMemorySize,
            ulCurAllocId,
            "Unknown Owner"
        );

    return  pMemoryPointer;
}


void*
AnscReAllocateMemory2
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize
    )
{
    void*                           pOldMemory = (void*)pMemoryBlock;
    void*                           pNewMemory = NULL;
    ULONG                           ulOldSize  = AnscGetMemorySize2(pOldMemory);
    ULONG                           ulNewSize  = ulMemorySize;
    ULONG                           ulCpySize  = AnscGetMin2(ulOldSize, ulNewSize);

    pNewMemory = AnscAllocateMemory2(ulNewSize);

    if ( !pNewMemory )
    {
        return  NULL;
    }
    else
    {
        AnscCopyMemory(pNewMemory, pOldMemory, ulCpySize);
    }

    AnscFreeMemory2(pOldMemory);

    return  pNewMemory;
}


void
AnscFreeMemory2
    (
        PVOID                       pMemoryBlock
    )
{
    if ( !pMemoryBlock )
    {
        return;
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr -= AnscGetMemorySize(pMemoryBlock);
    g_ulAllocatedItemCurr -= 1;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    AnscFlushMemory(pMemoryBlock);

    AnscDelMemoryAllocItem(pMemoryBlock);
}


ULONG
AnscGetMemorySize2
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus     = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = (PANSC_MEMORY_ALLOC_ITEM)AnscGetMemoryAllocItem(pMemoryBlock);

    if ( !pMemoryAllocItem )
    {
        return  0;
    }

    return  pMemoryAllocItem->MemorySize;
}


void*
AncResizeMemory2
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize
    )
{
    return  AnscReAllocateMemory2(pMemoryBlock, ulMemorySize);
}


void*
AnscAllocateMemory3
    (
        ULONG                       ulMemorySize
    )
{
    ANSC_STATUS                     returnStatus   = ANSC_STATUS_SUCCESS;
    void*                           pMemoryPointer = NULL;
    ULONG                           ulCurAllocId   = 0;

    if ( !g_bMumInitialized )
    {
        AnscInitializeSpinLock          (&g_tMumSpinLock);
        AnscInitializeMemoryAllocTable();

        AnscAcquireSpinLock(&g_tMumSpinLock);
        g_bMumInitialized     = TRUE;
        g_ulAllocatedSizeCurr = 0;
        g_ulAllocatedItemCurr = 0;
        AnscReleaseSpinLock(&g_tMumSpinLock);
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr += ulMemorySize;
    g_ulAllocatedItemCurr += 1;
    ulCurAllocId           = ++g_ulAllocIdentifier;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    pMemoryPointer = AnscAllocMemory(ulMemorySize + sizeof(ULONG));

    if ( !pMemoryPointer )
    {
        return  NULL;
    }
    else
    {
        *(PULONG)pMemoryPointer = ulMemorySize;

        pMemoryPointer = (PVOID)((ULONG)pMemoryPointer + sizeof(ULONG));
    }

    AnscAddMemoryAllocItem
        (
            pMemoryPointer,
            ulMemorySize,
            ulCurAllocId,
            "Unknown Owner"
        );

    return  pMemoryPointer;
}


void*
AnscReAllocateMemory3
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize
    )
{
    void*                           pOldMemory = (void*)pMemoryBlock;
    void*                           pNewMemory = NULL;
    ULONG                           ulOldSize  = AnscGetMemorySize3(pOldMemory);
    ULONG                           ulNewSize  = ulMemorySize;
    ULONG                           ulCpySize  = AnscGetMin2(ulOldSize, ulNewSize);

    pNewMemory = AnscAllocateMemory3(ulNewSize);

    if ( !pNewMemory )
    {
        return  NULL;
    }
    else
    {
        AnscCopyMemory(pNewMemory, pOldMemory, ulCpySize);
    }

    AnscFreeMemory3(pOldMemory);

    return  pNewMemory;
}


void
AnscFreeMemory3
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus   = ANSC_STATUS_SUCCESS;
    void*                           pMemoryPointer = NULL;
    ULONG                           ulMemorySize   = 0;

    if ( !pMemoryBlock )
    {
        return;
    }
    else
    {
        pMemoryPointer = (PVOID)((ULONG)pMemoryBlock - sizeof(ULONG));
        ulMemorySize   = *(PULONG)pMemoryPointer;
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr -= ulMemorySize;
    g_ulAllocatedItemCurr -= 1;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    AnscFlushMemory(pMemoryPointer);

    AnscDelMemoryAllocItem(pMemoryBlock);
}


ULONG
AnscGetMemorySize3
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus     = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = (PANSC_MEMORY_ALLOC_ITEM)AnscGetMemoryAllocItem(pMemoryBlock);

    if ( !pMemoryAllocItem )
    {
        return  0;
    }

    return  pMemoryAllocItem->MemorySize;
}


void*
AncResizeMemory3
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize
    )
{
    return  AnscReAllocateMemory3(pMemoryBlock, ulMemorySize);
}


void*
AnscAllocateMemory4
    (
        ULONG                       ulMemorySize,
        char*                       pFileName,
        ULONG                       ulLineNumber
    )
{
    ANSC_STATUS                     returnStatus   = ANSC_STATUS_SUCCESS;
    void*                           pMemoryPointer = NULL;
    ULONG                           ulCurAllocId   = 0;
    char*                           owner_desp     = NULL;
    char*                           pFileNameChar  = pFileName;

    if ( !g_bMumInitialized )
    {
        AnscInitializeSpinLock          (&g_tMumSpinLock);
        AnscInitializeMemoryAllocTable();

        AnscAcquireSpinLock(&g_tMumSpinLock);
        g_bMumInitialized     = TRUE;
        g_ulAllocatedSizeCurr = 0;
        g_ulAllocatedItemCurr = 0;
        AnscReleaseSpinLock(&g_tMumSpinLock);
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr += ulMemorySize;
    g_ulAllocatedItemCurr += 1;
    ulCurAllocId           = ++g_ulAllocIdentifier;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    pMemoryPointer = AnscAllocMemory(ulMemorySize + sizeof(ULONG));

    if ( !pMemoryPointer )
    {
        return  NULL;
    }
    else
    {
        *(PULONG)pMemoryPointer = ulMemorySize;

        pMemoryPointer = (PVOID)((ULONG)pMemoryPointer + sizeof(ULONG));
    }

    if ( pFileName )
    {
        /*
         * The file name passed into this function is the full path, we need to extract the file
         * name and store it in the memory block.
         */
        pFileNameChar  = pFileName;
        pFileNameChar += AnscSizeOfString(pFileName);

        while ( (*pFileNameChar != '/'      ) &&
                (*pFileNameChar != '\\'     ) &&
                ( pFileNameChar != pFileName) )
        {
            pFileNameChar--;
        }

        if ( (*pFileNameChar == '/') || (*pFileNameChar == '\\') )
        {
            pFileNameChar++;
        }

        owner_desp = (char*)AnscAllocMemory(256);

        if ( owner_desp )
        {
            if ( AnscSizeOfString(pFileNameChar) < 240 )
            {
                AnscCopyString( owner_desp,                               pFileNameChar);
                AnscCopyString(&owner_desp[AnscSizeOfString(owner_desp)], ": "         );
                _ansc_sprintf (&owner_desp[AnscSizeOfString(owner_desp)], "%d", ulLineNumber);
            }
            else
            {
                AnscCopyMemory(owner_desp, pFileNameChar, 240);
            }
        }
    }

    AnscAddMemoryAllocItem
        (
            pMemoryPointer,
            ulMemorySize,
            ulCurAllocId,
            owner_desp
        );

    if ( owner_desp )
    {
        AnscFlushMemory(owner_desp);
    }

    return  pMemoryPointer;
}


void*
AnscReAllocateMemory4
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize,
        char*                       pFileName,
        ULONG                       ulLineNumber
    )
{
    void*                           pOldMemory = (void*)pMemoryBlock;
    void*                           pNewMemory = NULL;
    ULONG                           ulOldSize  = AnscGetMemorySize4(pOldMemory);
    ULONG                           ulNewSize  = ulMemorySize;
    ULONG                           ulCpySize  = AnscGetMin2(ulOldSize, ulNewSize);

    pNewMemory = AnscAllocateMemory4(ulNewSize, pFileName, ulLineNumber);

    if ( !pNewMemory )
    {
        return  NULL;
    }
    else
    {
        AnscCopyMemory(pNewMemory, pOldMemory, ulCpySize);
    }

    AnscFreeMemory4(pOldMemory);

    return  pNewMemory;
}


void
AnscFreeMemory4
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus   = ANSC_STATUS_SUCCESS;
    void*                           pMemoryPointer = NULL;
    ULONG                           ulMemorySize   = 0;

    if ( !pMemoryBlock )
    {
        return;
    }
    else
    {
        pMemoryPointer = (PVOID)((ULONG)pMemoryBlock - sizeof(ULONG));
        ulMemorySize   = *(PULONG)pMemoryPointer;
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr -= ulMemorySize;
    g_ulAllocatedItemCurr -= 1;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    AnscFlushMemory(pMemoryPointer);

    AnscDelMemoryAllocItem(pMemoryBlock);
}


ULONG
AnscGetMemorySize4
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus     = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = (PANSC_MEMORY_ALLOC_ITEM)AnscGetMemoryAllocItem(pMemoryBlock);

    if ( !pMemoryAllocItem )
    {
        return  0;
    }

    return  pMemoryAllocItem->MemorySize;
}


void*
AncResizeMemory4
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize,
        char*                       pFileName,
        ULONG                       LineNumber
    )
{
    return  AnscReAllocateMemory4(pMemoryBlock, ulMemorySize, pFileName, LineNumber);
}


void*
AnscAllocateMemory5
    (
        ULONG                       ulMemorySize,
        char*                       pFileName,
        ULONG                       ulLineNumber
    )
{
    ANSC_STATUS                     returnStatus   = ANSC_STATUS_SUCCESS;
    void*                           pMemoryPointer = NULL;
    PUCHAR                          pMemoryArray1  = NULL;
    PUCHAR                          pMemoryArray2  = NULL;
    ULONG                           ulCurAllocId   = 0;
    char*                           pFileNameChar  = pFileName;
    ULONG                           i              = 0;
    char                            owner_desp[128];

    if ( !g_bMumInitialized )
    {
        AnscInitializeSpinLock(&g_tMumSpinLock);
        AnscInitializeMemoryAllocTable();

        AnscAcquireSpinLock(&g_tMumSpinLock);
        g_bMumInitialized     = TRUE;
        g_ulAllocatedSizeCurr = 0;
        g_ulAllocatedItemCurr = 0;
        AnscReleaseSpinLock(&g_tMumSpinLock);
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr += ulMemorySize;
    g_ulAllocatedItemCurr += 1;
    ulCurAllocId           = ++g_ulAllocIdentifier;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    pMemoryPointer = AnscAllocMemory(ulMemorySize + sizeof(ULONG) + ANSC_MEMORY_ALLOC_HEAD_SIZE + ANSC_MEMORY_ALLOC_TAIL_SIZE);

    if ( !pMemoryPointer )
    {
        AnscTraceWarning(("AnscAllocateMemory5 -- failed to allocate %lu bytes memory for %s:%lu!!!", ulMemorySize, pFileName, ulLineNumber));

        return  NULL;
    }
    else
    {
        *(PULONG)pMemoryPointer = ulMemorySize;

        pMemoryPointer = (PVOID )((ULONG)pMemoryPointer + sizeof(ULONG));
        pMemoryArray1  = (PUCHAR)pMemoryPointer;

        /*
        AnscWriteUlong(pMemoryArray1, 0x5C5C5C5C);
        pMemoryArray1 += 4;
        AnscWriteUlong(pMemoryArray1, 0x5C5C5C5C);
         */
        for ( i = 0; i < ANSC_MEMORY_ALLOC_HEAD_SIZE; i++ )
        {
            pMemoryArray1[i] = 0x5C;
        }

        pMemoryPointer = (PVOID )((ULONG)pMemoryPointer + ANSC_MEMORY_ALLOC_HEAD_SIZE);
        pMemoryArray2  = (PUCHAR)((ULONG)pMemoryPointer + ulMemorySize);

        /*
        AnscWriteUlong(pMemoryArray2, 0x7A7A7A7A);
        pMemoryArray2 += 4;
        AnscWriteUlong(pMemoryArray2, 0x7A7A7A7A);
         */
        for ( i = 0; i < ANSC_MEMORY_ALLOC_TAIL_SIZE; i++ )
        {
            pMemoryArray2[i] = 0x7A;
        }
    }

    if ( pFileName )
    {
        /*
         * The file name passed into this function is the full path, we need to extract the file
         * name and store it in the memory block.
         */
        pFileNameChar  = pFileName;
        pFileNameChar += AnscSizeOfString(pFileName);

        while ( (*pFileNameChar != '/'      ) &&
                (*pFileNameChar != '\\'     ) &&
                ( pFileNameChar != pFileName) )
        {
            pFileNameChar--;
        }

        if ( (*pFileNameChar == '/') || (*pFileNameChar == '\\') )
        {
            pFileNameChar++;
        }

        AnscZeroMemory(owner_desp, 128);

        if ( TRUE )
        {
            if ( AnscSizeOfString(pFileNameChar) < 110 )
            {
                AnscCopyString( owner_desp,                               pFileNameChar);
                AnscCopyString(&owner_desp[AnscSizeOfString(owner_desp)], ": "         );
                _ansc_sprintf (&owner_desp[AnscSizeOfString(owner_desp)], "%d", ulLineNumber);
            }
            else
            {
                AnscCopyMemory(owner_desp, pFileNameChar, 110);
            }
        }
    }

    AnscAddMemoryAllocItem
        (
            pMemoryPointer,
            ulMemorySize,
            ulCurAllocId,
            owner_desp
        );

    return  pMemoryPointer;
}


void*
AnscReAllocateMemory5
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize,
        char*                       pFileName,
        ULONG                       ulLineNumber
    )
{
    void*                           pOldMemory = (void*)pMemoryBlock;
    void*                           pNewMemory = NULL;
    ULONG                           ulOldSize  = AnscGetMemorySize5(pOldMemory);
    ULONG                           ulNewSize  = ulMemorySize;
    ULONG                           ulCpySize  = AnscGetMin2(ulOldSize, ulNewSize);

    pNewMemory = AnscAllocateMemory5(ulNewSize, pFileName, ulLineNumber);

    if ( !pNewMemory )
    {
        AnscTraceWarning(("AnscReAllocateMemory5 -- failed to allocate %lu bytes memory for %s:%lu!!!", ulMemorySize, pFileName, ulLineNumber));

        return  NULL;
    }
    else
    {
        AnscCopyMemory(pNewMemory, pOldMemory, ulCpySize);
    }

    AnscFreeMemory5(pOldMemory);

    return  pNewMemory;
}


void
AnscFreeMemory5
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus     = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PUCHAR                          pMemoryPointer   = NULL;
    PUCHAR                          pMemoryArray1    = NULL;
    PUCHAR                          pMemoryArray2    = NULL;
    ULONG                           ulMemorySize     = 0;
    ULONG                           i                = 0;

    PANSC_MEMORY_ALLOC_ITEM         pPrevAllocItem   = NULL;
    BOOLEAN                         bHeadCorrupted   = FALSE;
    BOOLEAN                         bTailCorrupted   = FALSE;

    if ( !pMemoryBlock )
    {
        return;
    }
    else
    {
        pMemoryPointer = (PVOID)((ULONG)pMemoryBlock - sizeof(ULONG) - ANSC_MEMORY_ALLOC_HEAD_SIZE);
        ulMemorySize   = *(PULONG)pMemoryPointer;
    }

    /*
     * Before we actually free the memory, we need to compare the signatures before and after the
     * memory block. If either signature has been modified, we need to do something noticeable to
     * warn the developer.
     */
    if ( TRUE )
    {
        pMemoryAllocItem = (PANSC_MEMORY_ALLOC_ITEM)AnscGetMemoryAllocItem(pMemoryBlock);
        pMemoryArray1    = (PUCHAR                 )((ULONG)pMemoryBlock - ANSC_MEMORY_ALLOC_HEAD_SIZE);
        pMemoryArray2    = (PUCHAR                 )((ULONG)pMemoryBlock + ulMemorySize);

        for ( i = 0; i < ANSC_MEMORY_ALLOC_TAIL_SIZE; i++ )
        {
            if ( pMemoryArray2[i] != 0x7A )
            {
                bTailCorrupted = TRUE;

                AnscTraceWarning
                    ((
                        "!!Sky is falling down, memory block 0x%lX was written out of boundary!! owner = %s, size = %lu/%lu!\n",
                        pMemoryBlock,
                        pMemoryAllocItem->OwnerDesp,
                        ulMemorySize,
                        pMemoryAllocItem->MemorySize
                    ));

                break;
            }
        }

        for ( i = 0; i < ANSC_MEMORY_ALLOC_HEAD_SIZE; i++ )
        {
            if ( pMemoryArray1[i] != 0x5C )
            {
                bHeadCorrupted = TRUE;

                AnscTraceWarning
                    ((
                        "!!Sky is falling down, memory block 0x%lX was written out of boundary!! owner = %s, size = %lu/%lu, ",
                        pMemoryBlock,
                        pMemoryAllocItem->OwnerDesp,
                        ulMemorySize,
                        pMemoryAllocItem->MemorySize
                    ));

                pPrevAllocItem = AnscGetPrevMemoryAllocItem(pMemoryBlock);

                if ( !pPrevAllocItem )
                {
                    AnscTraceWarning(("Cannot find the memory block before this one!!!\n"));
                }
                else
                {
                    pMemoryArray1    = (PUCHAR)((ULONG)pPrevAllocItem->MemoryPointer - ANSC_MEMORY_ALLOC_HEAD_SIZE);
                    pMemoryArray2    = (PUCHAR)((ULONG)pPrevAllocItem->MemoryPointer + pPrevAllocItem->MemorySize);

                    AnscTraceWarning
                        ((
                            "Found the memory block before this one, memory pointer = 0x%lX, owner = %s. Head/Tail content = 0x%lX 0x%lX/0x%lX 0x%lX.\n",
                            pPrevAllocItem->MemoryPointer,
                            pPrevAllocItem->OwnerDesp,
                            AnscReadUlong(pMemoryArray1),
                            AnscReadUlong((pMemoryArray1 + 4)),
                            AnscReadUlong(pMemoryArray2),
                            AnscReadUlong((pMemoryArray2 + 4))
                        ));
                }
            }
        }

        if ( bHeadCorrupted || bTailCorrupted )
        {
            ULONG                   ulIndex         = 0;
            ULONG                   ulFullMemSize   = sizeof(ULONG) + ANSC_MEMORY_ALLOC_HEAD_SIZE + ulMemorySize + ANSC_MEMORY_ALLOC_TAIL_SIZE;

            AnscTraceWarning(("Dump out the content of memory block 0x%lX, size = %lu, full size = %lu:", pMemoryBlock, ulMemorySize, ulFullMemSize));

            for ( ulIndex = 0; ulIndex < (ulFullMemSize - (ulFullMemSize % 16)); ulIndex++ )
            {
                if ( (ulIndex % 16) == 0 )
                {
                    AnscTraceWarning(("\n%08lX: %02X", pMemoryPointer + ulIndex, pMemoryPointer[ulIndex]));
                }
                else
                {
                    AnscTraceWarning((" %02X", pMemoryPointer[ulIndex]));
                }
            }

            for ( ; ulIndex < ulFullMemSize; ulIndex++ )
            {
                if ( (ulIndex % 16) == 0 )
                {
                    AnscTraceWarning(("\n%08lX: %02X", pMemoryPointer + ulIndex, pMemoryPointer[ulIndex]));
                }
                else
                {
                    AnscTraceWarning((" %02X", pMemoryPointer[ulIndex]));
                }
            }

            AnscTraceWarning(("\n"));

        #if defined(_ANSC_LINUX) && defined(_ANSC_KERNEL)
            BUG();
        #endif
        }
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    g_ulAllocatedSizeCurr -= ulMemorySize;
    g_ulAllocatedItemCurr -= 1;
    AnscReleaseSpinLock(&g_tMumSpinLock);

    /*
     *  zero out the memory block, which helps on finding out whether it is being referenced by other parties
     */
    _ansc_memset(pMemoryPointer, 0, sizeof(ULONG) + ANSC_MEMORY_ALLOC_HEAD_SIZE + ulMemorySize + ANSC_MEMORY_ALLOC_TAIL_SIZE);

    AnscFlushMemory(pMemoryPointer);

    AnscDelMemoryAllocItem(pMemoryBlock);
}


ULONG
AnscGetMemorySize5
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus     = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = (PANSC_MEMORY_ALLOC_ITEM)AnscGetMemoryAllocItem(pMemoryBlock);

    if ( !pMemoryAllocItem )
    {
        return  0;
    }

    return  pMemoryAllocItem->MemorySize;
}


void*
AncResizeMemory5
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize,
        char*                       pFileName,
        ULONG                       LineNumber
    )
{
    return  AnscReAllocateMemory5(pMemoryBlock, ulMemorySize, pFileName, LineNumber);
}


void*
AnscAllocateMemory6
    (
        ULONG                       ulMemorySize
    )
{
    ANSC_STATUS                     returnStatus      = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_DESCRIPTOR         pMemoryDescriptor = NULL;
    PANSC_MEMORY_POOL               pMemoryPool       = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry       = NULL;
    ULONG                           ulMinFreeMemory   = 0;
    ULONG                           ulCurFreeMemory   = AnscGetFreeMemory();

    if ( !g_bMpmInitialized )
    {
        AnscInitializeSpinLock       (&g_tMpmSpinLock);
        AnscInitializeMemoryPoolTable();

        AnscAcquireSpinLock(&g_tMpmSpinLock);
        g_bMpmInitialized = TRUE;
        AnscReleaseSpinLock(&g_tMpmSpinLock);
    }

    AnscAcquireSpinLock(&g_tMemPoolTableSpinLock);

    pMemoryPool = (PANSC_MEMORY_POOL)AnscGetMemoryPool(ulMemorySize);

    if ( pMemoryPool )
    {
        pSLinkEntry = AnscSListPopEntry(&pMemoryPool->MdoSList);

        if ( pSLinkEntry )
        {
            pMemoryDescriptor = ACCESS_ANSC_MEMORY_DESCRIPTOR(pSLinkEntry);

            AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

            return  pMemoryDescriptor->Data;
        }

        ulMinFreeMemory = pMemoryPool->MinFreeMemorySize;
    }

    AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

    if ( (ulMinFreeMemory > 0) && (ulCurFreeMemory != 0xFFFFFFFF) )
    {
        if ( ulMinFreeMemory >= ulCurFreeMemory )
        {
            return  NULL;
        }
    }

    pMemoryDescriptor = (PANSC_MEMORY_DESCRIPTOR)AnscAllocMemory(ulMemorySize + sizeof(ANSC_MEMORY_DESCRIPTOR));

    if ( !pMemoryDescriptor )
    {
        return  NULL;
    }
    else
    {
        pMemoryDescriptor->BlockSize = ulMemorySize;
    }

    return  (void*)pMemoryDescriptor->Data;
}


void*
AnscReAllocateMemory6
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize
    )
{
    void*                           pOldMemory = (void*)pMemoryBlock;
    void*                           pNewMemory = NULL;
    ULONG                           ulOldSize  = AnscGetMemorySize6(pOldMemory);
    ULONG                           ulNewSize  = ulMemorySize;
    ULONG                           ulCpySize  = AnscGetMin2(ulOldSize, ulNewSize);

    pNewMemory = AnscAllocateMemory6(ulNewSize);

    if ( !pNewMemory )
    {
        return  NULL;
    }
    else
    {
        AnscCopyMemory(pNewMemory, pOldMemory, ulCpySize);
    }

    AnscFreeMemory6(pOldMemory);

    return  pNewMemory;
}


void
AnscFreeMemory6
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus      = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_DESCRIPTOR         pMemoryDescriptor = NULL;
    PANSC_MEMORY_POOL               pMemoryPool       = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry       = NULL;

    if ( !pMemoryBlock )
    {
        return;
    }
    else
    {
        pMemoryDescriptor = ACCESS_ANSC_MEMORY_DESCRIPTOR_BYDATA(pMemoryBlock);
    }

    AnscAcquireSpinLock(&g_tMemPoolTableSpinLock);

    pMemoryPool = (PANSC_MEMORY_POOL)AnscGetMemoryPool(pMemoryDescriptor->BlockSize);

    if ( pMemoryPool )
    {
        AnscSListPushEntry(&pMemoryPool->MdoSList, &pMemoryDescriptor->Linkage);
    }

    AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

    if ( !pMemoryPool )
    {
        AnscFlushMemory(pMemoryDescriptor);
    }

    return;
}


ULONG
AnscGetMemorySize6
    (
        PVOID                       pMemoryBlock
    )
{
    ANSC_STATUS                     returnStatus      = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_DESCRIPTOR         pMemoryDescriptor = NULL;

    if ( !pMemoryBlock )
    {
        return  0;
    }
    else
    {
        pMemoryDescriptor = ACCESS_ANSC_MEMORY_DESCRIPTOR_BYDATA(pMemoryBlock);
    }

    return  pMemoryDescriptor->BlockSize;
}


void*
AncResizeMemory6
    (
        PVOID                       pMemoryBlock,
        ULONG                       ulMemorySize
    )
{
    return  AnscReAllocateMemory6(pMemoryBlock, ulMemorySize);
}


void
AnscTraceMemoryUsage
    (
        void
    )
{
    if ( !g_bMumInitialized )
    {
        AnscInitializeSpinLock(&g_tMumSpinLock);
        AnscInitializeMemoryAllocTable();

        g_bMumInitialized = TRUE;
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    AnscTraceError(("\n --- Curr memory usage of ANSC platform is %d bytes, %d blocks! ---\n", g_ulAllocatedSizeCurr, g_ulAllocatedItemCurr));
    AnscTraceError(("\n --- Peak memory usage of ANSC platform is %d bytes, %d blocks! ---\n", g_ulAllocatedSizePeak, g_ulAllocatedItemPeak));
    AnscReleaseSpinLock(&g_tMumSpinLock);

    return;
}


char*
AnscTraceMemoryUsage2
    (
        ULONG                       ulTraceMask,
        char*                       pOwnerDesp
    )
{
    char*                           pTraceMessage    = NULL;
    ULONG                           ulTotalBytes     = 0;
    ULONG                           ulTotalBlocks    = 0;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry      = NULL;
    ULONG                           i                = 0;
    ULONG                           ulCurrentAllocId = g_ulAllocIdentifier;

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);

    for ( i = 0; i < ANSC_MEMORY_ALLOC_TABLE_SIZE; i++ )
    {
        pSLinkEntry = AnscSListGetFirstEntry(&g_tAllocTable[i]);

        while ( pSLinkEntry )
        {
            pMemoryAllocItem = ACCESS_ANSC_MEMORY_ALLOC_ITEM(pSLinkEntry);
            pSLinkEntry      = AnscSListGetNextEntry(pSLinkEntry);

            if ( pMemoryAllocItem->AllocId > ulCurrentAllocId )
            {
                continue;
            }
            else if ( (ulTraceMask & ANSC_MEMORY_TRACE_byMarker) && (pMemoryAllocItem->Timestamp <= g_ulTimeMarker) )
            {
                continue;
            }
            else if ( (ulTraceMask & ANSC_MEMORY_TRACE_byOwner) && pOwnerDesp &&
                      !AnscEqualString2
                        (
                            pOwnerDesp,
                            pMemoryAllocItem->OwnerDesp,
                            AnscGetMin2(AnscSizeOfString(pOwnerDesp), AnscSizeOfString(pMemoryAllocItem->OwnerDesp)),
                            FALSE
                        ) )
            {
                continue;
            }

            ulTotalBytes += pMemoryAllocItem->MemorySize;
            ulTotalBlocks++;
        }
    }

    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    /*
     * Instead of printing out the debug message directly, we return a trace message.
     */
    pTraceMessage = (char*)AnscAllocateMemory(128);

    if ( pTraceMessage )
    {
        _ansc_sprintf
            (
                pTraceMessage,
                "Memory usage is %d bytes, %d blocks!",
                ulTotalBytes,
                ulTotalBlocks
            );
    }

    AnscAcquireSpinLock(&g_tMumSpinLock);
    AnscTraceError(("\n --- Curr memory usage of ANSC platform is %d bytes, %d blocks! ---\n", g_ulAllocatedSizeCurr, g_ulAllocatedItemCurr));
    AnscTraceError(("\n --- Peak memory usage of ANSC platform is %d bytes, %d blocks! ---\n", g_ulAllocatedSizePeak, g_ulAllocatedItemPeak));
    AnscReleaseSpinLock(&g_tMumSpinLock);

    return  pTraceMessage;
}


void
AnscInitializeMemoryAllocTable
    (
        void
    )
{
    ULONG                           i = 0;

    for ( i = 0; i < ANSC_MEMORY_ALLOC_TABLE_SIZE; i++ )
    {
        AnscSListInitializeHeader(&g_tAllocTable[i]);
    }
    AnscInitializeSpinLock(&g_tAllocTableSpinLock);

    return;
}


void
AnscAddMemoryAllocItem
    (
        void*                       pointer,
        ULONG                       size,
        ULONG                       alloc_id,
        char*                       owner_desp
    )
{
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = (PANSC_MEMORY_ALLOC_ITEM)AnscAllocMemory(sizeof(ANSC_MEMORY_ALLOC_ITEM));
    ULONG                           ulHashIndex      = AnscHashUlong((ULONG)pointer, ANSC_MEMORY_ALLOC_TABLE_SIZE);

    if ( g_ulAllocatedSizeCurr > g_ulAllocatedSizePeak )
    {
        g_ulAllocatedSizePeak = g_ulAllocatedSizeCurr;
        g_ulAllocatedItemPeak = g_ulAllocatedItemCurr;
    }

    if ( !pMemoryAllocItem )
    {
        return;
    }
    else
    {
        pMemoryAllocItem->HashIndex     = ulHashIndex;
        pMemoryAllocItem->AllocId       = alloc_id;
        pMemoryAllocItem->MemoryPointer = pointer;
        pMemoryAllocItem->MemorySize    = size;
        pMemoryAllocItem->Timestamp     = AnscGetTickInSeconds();

        if ( owner_desp )
        {
            AnscCopyString(pMemoryAllocItem->OwnerDesp, owner_desp);
        }
    }

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);
    AnscSListPushEntry (&g_tAllocTable[ulHashIndex], &pMemoryAllocItem->Linkage);
    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    return;
}


ANSC_HANDLE
AnscGetMemoryAllocItem
    (
        void*                       pointer
    )
{
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry      = NULL;
    ULONG                           ulHashIndex      = AnscHashUlong((ULONG)pointer, ANSC_MEMORY_ALLOC_TABLE_SIZE);

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);

    pSLinkEntry = AnscSListGetFirstEntry(&g_tAllocTable[ulHashIndex]);

    while ( pSLinkEntry )
    {
        pMemoryAllocItem = ACCESS_ANSC_MEMORY_ALLOC_ITEM(pSLinkEntry);
        pSLinkEntry      = AnscSListGetNextEntry(pSLinkEntry);

        if ( (void*)pMemoryAllocItem->MemoryPointer == pointer )
        {
            AnscReleaseSpinLock(&g_tAllocTableSpinLock);

            return  (ANSC_HANDLE)pMemoryAllocItem;
        }
    }

    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    return  (ANSC_HANDLE)NULL;
}


ANSC_HANDLE
AnscGetPrevMemoryAllocItem
    (
        void*                       pointer
    )
{
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry      = NULL;
    ULONG                           ulHashIndex      = 0;
    PANSC_MEMORY_ALLOC_ITEM         pPrevAllocItem   = NULL;

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);

    for ( ulHashIndex = 0; ulHashIndex < ANSC_MEMORY_ALLOC_TABLE_SIZE; ulHashIndex++ )
    {
        pSLinkEntry = AnscSListGetFirstEntry(&g_tAllocTable[ulHashIndex]);

        while ( pSLinkEntry )
        {
            pMemoryAllocItem = ACCESS_ANSC_MEMORY_ALLOC_ITEM(pSLinkEntry);
            pSLinkEntry      = AnscSListGetNextEntry(pSLinkEntry);

            if ( pMemoryAllocItem->MemoryPointer < pointer )
            {
                if ( pPrevAllocItem == NULL )
                {
                    pPrevAllocItem = pMemoryAllocItem;
                }
                else if ( pMemoryAllocItem->MemoryPointer >= pPrevAllocItem->MemoryPointer )
                {
                    pPrevAllocItem = pMemoryAllocItem;
                }
            }
        }
    }

    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    return  (ANSC_HANDLE)pPrevAllocItem;
}


void
AnscDelMemoryAllocItem
    (
        void*                       pointer
    )
{
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry      = NULL;
    ULONG                           ulHashIndex      = AnscHashUlong((ULONG)pointer, ANSC_MEMORY_ALLOC_TABLE_SIZE);

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);

    pSLinkEntry = AnscSListGetFirstEntry(&g_tAllocTable[ulHashIndex]);

    while ( pSLinkEntry )
    {
        pMemoryAllocItem = ACCESS_ANSC_MEMORY_ALLOC_ITEM(pSLinkEntry);
        pSLinkEntry      = AnscSListGetNextEntry(pSLinkEntry);

        if ( (void*)pMemoryAllocItem->MemoryPointer == pointer )
        {
            AnscSListPopEntryByLink(&g_tAllocTable[ulHashIndex], &pMemoryAllocItem->Linkage);

            AnscFlushMemory(pMemoryAllocItem);

            break;
        }
    }

    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    return;
}


void
AnscTraceMemoryTable
    (
        void
    )
{
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry      = NULL;
    ULONG                           i                = 0;

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);

    for ( i = 0; i < ANSC_MEMORY_ALLOC_TABLE_SIZE; i++ )
    {
        pSLinkEntry = AnscSListGetFirstEntry(&g_tAllocTable[i]);

        while ( pSLinkEntry )
        {
            pMemoryAllocItem = ACCESS_ANSC_MEMORY_ALLOC_ITEM(pSLinkEntry);
            pSLinkEntry      = AnscSListGetNextEntry(pSLinkEntry);

            AnscTraceError
                ((
                    " *** mem_block = 0x%8X, size = %7d bytes, id = %8d, %s ***\n",
                    pMemoryAllocItem->MemoryPointer,
                    pMemoryAllocItem->MemorySize,
                    pMemoryAllocItem->AllocId,
                    pMemoryAllocItem->OwnerDesp
                ));
        }
    }

    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    return;
}


char**
AnscTraceMemoryTable2
    (
        ULONG                       ulTraceMask,
        char*                       pOwnerDesp,
        PULONG                      pulBlockCount
    )
{
    char**                          pTraceMsgArray   = NULL;
    char*                           pTraceMessage    = NULL;
    ULONG                           ulTotalBlocks    = 0;
    ULONG                           ulMaxBlockCount  = (*pulBlockCount > 0)? AnscGetMin2(*pulBlockCount, 1024) : 1024;
    PANSC_MEMORY_ALLOC_ITEM         pMemoryAllocItem = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry      = NULL;
    ULONG                           i                = 0;
    ULONG                           ulCurrentAllocId = g_ulAllocIdentifier;

    /*
     * We shall limit the number of trace messages to 1024.
     */
    pTraceMsgArray = (char**)AnscAllocateMemory(sizeof(char*) * ulMaxBlockCount);

    if ( !pTraceMsgArray )
    {
        *pulBlockCount = 0;

        return  pTraceMsgArray;
    }

    AnscAcquireSpinLock(&g_tAllocTableSpinLock);

    for ( i = 0; i < ANSC_MEMORY_ALLOC_TABLE_SIZE; i++ )
    {
        pSLinkEntry = AnscSListGetFirstEntry(&g_tAllocTable[i]);

        while ( pSLinkEntry )
        {
            pMemoryAllocItem = ACCESS_ANSC_MEMORY_ALLOC_ITEM(pSLinkEntry);
            pSLinkEntry      = AnscSListGetNextEntry(pSLinkEntry);

            if ( pMemoryAllocItem->AllocId > ulCurrentAllocId )
            {
                continue;
            }
            else if ( (ulTraceMask & ANSC_MEMORY_TRACE_byMarker) && (pMemoryAllocItem->Timestamp <= g_ulTimeMarker) )
            {
                continue;
            }
            else if ( (ulTraceMask & ANSC_MEMORY_TRACE_byOwner) && pOwnerDesp &&
                      !AnscEqualString2
                        (
                            pOwnerDesp,
                            pMemoryAllocItem->OwnerDesp,
                            AnscGetMin2(AnscSizeOfString(pOwnerDesp), AnscSizeOfString(pMemoryAllocItem->OwnerDesp)),
                            FALSE
                        ) )
            {
                continue;
            }

            pTraceMessage = (char*)AnscAllocateMemory(128);

            if ( !pTraceMessage )
            {
                continue;
            }
            else
            {
                pTraceMsgArray[ulTotalBlocks++] = pTraceMessage;
            }

            _ansc_sprintf
                (
                    pTraceMessage,
                    " *** mem_block = 0x%8X, size = %9d bytes, id = %6d, %s ***",
                    pMemoryAllocItem->MemoryPointer,
                    pMemoryAllocItem->MemorySize,
                    pMemoryAllocItem->AllocId,
                    pMemoryAllocItem->OwnerDesp
                );

            if ( ulTotalBlocks >= ulMaxBlockCount )
            {
                break;
            }
        }
    }

    AnscReleaseSpinLock(&g_tAllocTableSpinLock);

    *pulBlockCount = ulTotalBlocks;

    return  pTraceMsgArray;
}


void
AnscExpand2
    (
        PVOID                       i_buffer,
        PVOID                       o_buffer,
        int                         n_bytes,
        BOOL                        b_ljustified
    )
{
    PUCHAR                          p_uchar  = (PUCHAR )i_buffer;
    PUSHORT                         p_ushort = (PUSHORT)o_buffer;
    ULONG                           i        = 0;

    for ( i = 0; i < (ULONG)n_bytes; i++ )
    {
        if ( b_ljustified )
        {
            p_ushort[i] = ((USHORT)p_uchar[i]) << 8;
        }
        else
        {
            p_ushort[i] = (USHORT)p_uchar[i];
        }
    }

    return;
}


void
AnscMemorySetTimeMarker
    (
        void
    )
{
    g_ulTimeMarker = AnscGetTickInSeconds();

    return;
}


void
AnscInitializeMemoryPoolTable
    (
        void
    )
{
    ULONG                           i = 0;

    for ( i = 0; i < ANSC_MEMORY_POOL_TABLE_SIZE; i++ )
    {
        AnscQueueInitializeHeader(&g_tMemPoolTable[i]);
    }
    AnscInitializeSpinLock(&g_tMemPoolTableSpinLock);

    return;
}


ANSC_HANDLE
AnscGetMemoryPool
    (
        ULONG                       ulBlockSize
    )
{
    ANSC_STATUS                     returnStatus = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_POOL               pMemoryPool  = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry  = NULL;
    ULONG                           ulHashIndex  = AnscHashUlong(ulBlockSize, ANSC_MEMORY_POOL_TABLE_SIZE);

    pSLinkEntry = AnscQueueGetFirstEntry(&g_tMemPoolTable[ulHashIndex]);

    while ( pSLinkEntry )
    {
        pMemoryPool = ACCESS_ANSC_MEMORY_POOL(pSLinkEntry);
        pSLinkEntry = AnscQueueGetNextEntry(pSLinkEntry);

        if ( pMemoryPool->BlockSize == ulBlockSize )
        {
            return  (ANSC_HANDLE)pMemoryPool;
        }
    }

    return  (ANSC_HANDLE)NULL;
}


void
AnscAddMemoryPool
    (
        ULONG                       ulBlockSize,
        ULONG                       ulMinFreeMemorySize
    )
{
    ANSC_STATUS                     returnStatus = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_POOL               pMemoryPool  = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry  = NULL;
    ULONG                           ulHashIndex  = AnscHashUlong(ulBlockSize, ANSC_MEMORY_POOL_TABLE_SIZE);

    if ( !g_bMpmInitialized )
    {
        AnscInitializeSpinLock(&g_tMpmSpinLock);
        AnscInitializeMemoryPoolTable();

        AnscAcquireSpinLock(&g_tMpmSpinLock);
        g_bMpmInitialized = TRUE;
        AnscReleaseSpinLock(&g_tMpmSpinLock);
    }

    AnscAcquireSpinLock(&g_tMemPoolTableSpinLock);

    if ( AnscGetMemoryPool(ulBlockSize) )
    {
        AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

        return;
    }
    else
    {
        pMemoryPool = (PANSC_MEMORY_POOL)AnscAllocMemory(sizeof(ANSC_MEMORY_POOL));
    }

    if ( pMemoryPool )
    {
        pMemoryPool->BlockSize         = ulBlockSize;
        pMemoryPool->MinFreeMemorySize = ulMinFreeMemorySize;

        AnscQueuePushEntry(&g_tMemPoolTable[ulHashIndex], &pMemoryPool->Linkage);
    }

    AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

    return;
}


void
AnscDelMemoryPool
    (
        ULONG                       ulBlockSize
    )
{
    ANSC_STATUS                     returnStatus = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_POOL               pMemoryPool  = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry  = NULL;
    ULONG                           ulHashIndex  = AnscHashUlong(ulBlockSize, ANSC_MEMORY_POOL_TABLE_SIZE);

    AnscAcquireSpinLock(&g_tMemPoolTableSpinLock);

    pSLinkEntry = AnscQueueGetFirstEntry(&g_tMemPoolTable[ulHashIndex]);

    while ( pSLinkEntry )
    {
        pMemoryPool = ACCESS_ANSC_MEMORY_POOL(pSLinkEntry);
        pSLinkEntry = AnscQueueGetNextEntry(pSLinkEntry);

        if ( pMemoryPool->BlockSize == ulBlockSize )
        {
            AnscQueuePopEntryByLink(&g_tMemPoolTable[ulHashIndex], &pMemoryPool->Linkage);

            AnscClrMemoryPool2((ANSC_HANDLE)pMemoryPool, AnscSListQueryDepth(&pMemoryPool->MdoSList));

            AnscFlushMemory(pMemoryPool);

            break;
        }
    }

    AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

    return;
}


void
AnscClrMemoryPool1
    (
        ULONG                       ulBlockSize,
        ULONG                       ulNumberOfBlocks
    )
{
    ANSC_STATUS                     returnStatus = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_POOL               pMemoryPool  = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry  = NULL;
    ULONG                           ulHashIndex  = AnscHashUlong(ulBlockSize, ANSC_MEMORY_POOL_TABLE_SIZE);

    AnscAcquireSpinLock(&g_tMemPoolTableSpinLock);

    pSLinkEntry = AnscQueueGetFirstEntry(&g_tMemPoolTable[ulHashIndex]);

    while ( pSLinkEntry )
    {
        pMemoryPool = ACCESS_ANSC_MEMORY_POOL(pSLinkEntry);
        pSLinkEntry = AnscQueueGetNextEntry(pSLinkEntry);

        if ( pMemoryPool->BlockSize == ulBlockSize )
        {
            AnscClrMemoryPool2((ANSC_HANDLE)pMemoryPool, ulNumberOfBlocks);

            break;
        }
    }

    AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

    return;
}


void
AnscClrMemoryPool2
    (
        ANSC_HANDLE                 hMemoryPool,
        ULONG                       ulNumberOfBlocks
    )
{
    ANSC_STATUS                     returnStatus      = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_POOL               pMemoryPool       = (PANSC_MEMORY_POOL      )hMemoryPool;
    PANSC_MEMORY_DESCRIPTOR         pMemoryDescriptor = (PANSC_MEMORY_DESCRIPTOR)NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry       = NULL;
    ULONG                           i                 = 0;

    for ( i = 0; i < ulNumberOfBlocks; i++ )
    {
        pSLinkEntry = AnscSListPopEntry(&pMemoryPool->MdoSList);

        if ( pSLinkEntry )
        {
            pMemoryDescriptor = ACCESS_ANSC_MEMORY_DESCRIPTOR(pSLinkEntry);

            AnscFlushMemory(pMemoryDescriptor);
        }
        else
        {
            break;
        }
    }

    return;
}


void
AnscDelAllMemoryPools
    (
        void
    )
{
    ANSC_STATUS                     returnStatus = ANSC_STATUS_SUCCESS;
    PANSC_MEMORY_POOL               pMemoryPool  = NULL;
    PSINGLE_LINK_ENTRY              pSLinkEntry  = NULL;
    ULONG                           i            = 0;

    AnscAcquireSpinLock(&g_tMemPoolTableSpinLock);

    for ( i = 0; i < ANSC_MEMORY_POOL_TABLE_SIZE; i++ )
    {
        pSLinkEntry = AnscQueuePopEntry(&g_tMemPoolTable[i]);

        while ( pSLinkEntry )
        {
            pMemoryPool = ACCESS_ANSC_MEMORY_POOL(pSLinkEntry);
            pSLinkEntry = AnscQueuePopEntry(&g_tMemPoolTable[i]);

            AnscClrMemoryPool2((ANSC_HANDLE)pMemoryPool, AnscSListQueryDepth(&pMemoryPool->MdoSList));

            AnscFlushMemory(pMemoryPool);
        }
    }

    AnscReleaseSpinLock(&g_tMemPoolTableSpinLock);

    return;
}
